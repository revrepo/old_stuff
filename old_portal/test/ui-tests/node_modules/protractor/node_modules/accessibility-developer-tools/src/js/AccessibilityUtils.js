// Copyright 2012 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.require('axs.constants');
goog.provide('axs.utils');
goog.provide('axs.utils.Color');

/**
 * @const
 * @type {string}
 */
axs.utils.FOCUSABLE_ELEMENTS_SELECTOR =
    'input:not([type=hidden]):not([disabled]),' +
    'select:not([disabled]),' +
    'textarea:not([disabled]),' +
    'button:not([disabled]),' +
    'a[href],' +
    'iframe,' +
    '[tabindex]';

/**
 * @constructor
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @param {number} alpha
 */
axs.utils.Color = function(red, green, blue, alpha) {
    /** @type {number} */
    this.red = red;

    /** @type {number} */
    this.green = green;

    /** @type {number} */
    this.blue = blue;

    /** @type {number} */
    this.alpha = alpha;
};

/**
 * Calculate the contrast ratio between the two given colors. Returns the ratio
 * to 1, for example for two two colors with a contrast ratio of 21:1, this
 * function will return 21.
 * @param {axs.utils.Color} fgColor
 * @param {axs.utils.Color} bgColor
 * @return {?number}
 */
axs.utils.calculateContrastRatio = function(fgColor, bgColor) {
    if (!fgColor || !bgColor)
        return null;

    if (fgColor.alpha < 1)
        fgColor = axs.utils.flattenColors(fgColor, bgColor);

    var fgLuminance = axs.utils.calculateLuminance(fgColor);
    var bgLuminance = axs.utils.calculateLuminance(bgColor);
    var contrastRatio = (Math.max(fgLuminance, bgLuminance) + 0.05) /
        (Math.min(fgLuminance, bgLuminance) + 0.05);
    return contrastRatio;
};

axs.utils.luminanceRatio = function(luminance1, luminance2) {
    return (Math.max(luminance1, luminance2) + 0.05) /
        (Math.min(luminance1, luminance2) + 0.05);
};

/**
 * Returns the nearest ancestor which is an Element.
 * @param {Node} node
 * @return {Element}
 */
axs.utils.parentElement = function(node) {
    if (!node)
        return null;
    if (node.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
        return node.host;

    var parentElement = node.parentElement;
    if (parentElement)
        return parentElement;

    var parentNode = node.parentNode;
    if (!parentNode)
        return null;

    switch (parentNode.nodeType) {
    case Node.ELEMENT_NODE:
        return /** @type {Element} */ (parentNode);
    case Node.DOCUMENT_FRAGMENT_NODE:
        return parentNode.host;
    default:
        return null;
    }
};

/**
 * Return the corresponding element for the given node.
 * @param {Node} node
 * @return {Element}
 * @suppress {checkTypes}
 */
axs.utils.asElement = function(node) {
    /** @type {Element} */ var element;
    switch (node.nodeType) {
    case Node.COMMENT_NODE:
        return null;  // Skip comments
    case Node.ELEMENT_NODE:
        element = /** (@type {Element}) */ node;
        if (element.tagName.toLowerCase() == 'script')
            return null;  // Skip script elements
        break;
    case Node.TEXT_NODE:
        element = axs.utils.parentElement(node);
        break;
    default:
        console.warn('Unhandled node type: ', node.nodeType);
        return null;
    }
    return element;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementIsTransparent = function(element) {
    return element.style.opacity == '0';
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementHasZeroArea = function(element) {
    var rect = element.getBoundingClientRect();
    var width = rect.right - rect.left;
    var height = rect.top - rect.bottom;
    if (!width || !height)
        return true;
    return false;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementIsOutsideScrollArea = function(element) {
    var parent = axs.utils.parentElement(element);

    var defaultView = element.ownerDocument.defaultView;
    while (parent != defaultView.document.body) {
        if (axs.utils.isClippedBy(element, parent))
            return true;

        if (axs.utils.canScrollTo(element, parent) && !axs.utils.elementIsOutsideScrollArea(parent))
            return false;

        parent = axs.utils.parentElement(parent);
    }

    return !axs.utils.canScrollTo(element, defaultView.document.body);
};

/**
 * Checks whether it's possible to scroll to the given element within the given container.
 * Assumes that |container| is an ancestor of |element|.
 * If |container| cannot be scrolled, returns True if the element is within its bounding client
 * rect.
 * @param {Element} element
 * @param {Element} container
 * @return {boolean} True iff it's possible to scroll to |element| within |container|.
 */
axs.utils.canScrollTo = function(element, container) {
    var rect = element.getBoundingClientRect();
    var containerRect = container.getBoundingClientRect();
    var containerTop = containerRect.top;
    var containerLeft = containerRect.left;
    var containerScrollArea =
        { top: containerTop - container.scrollTop,
          bottom: containerTop - container.scrollTop + container.scrollHeight,
          left: containerLeft - container.scrollLeft,
          right: containerLeft - container.scrollLeft + container.scrollWidth };

    if (rect.right < containerScrollArea.left || rect.bottom < containerScrollArea.top ||
            rect.left > containerScrollArea.right || rect.top > containerScrollArea.bottom) {
        return false;
    }

    var defaultView = element.ownerDocument.defaultView;
    var style = defaultView.getComputedStyle(container);

    if (rect.left > containerRect.right || rect.top > containerRect.bottom) {
        return (style.overflow == 'scroll' || style.overflow == 'auto' ||
                container instanceof defaultView.HTMLBodyElement);
    }

    return true;
};

/**
 * Checks whether the given element is clipped by the given container.
 * Assumes that |container| is an ancestor of |element|.
 * @param {Element} element
 * @param {Element} container
 * @return {boolean} True iff |element| is clipped by |container|.
 */
axs.utils.isClippedBy = function(element, container) {
    var rect = element.getBoundingClientRect();
    var containerRect = container.getBoundingClientRect();
    var containerTop = containerRect.top;
    var containerLeft = containerRect.left;
    var containerScrollArea =
        { top: containerTop - container.scrollTop,
          bottom: containerTop - container.scrollTop + container.scrollHeight,
          left: containerLeft - container.scrollLeft,
          right: containerLeft - container.scrollLeft + container.scrollWidth };

    var defaultView = element.ownerDocument.defaultView;
    var style = defaultView.getComputedStyle(container);

    if ((rect.right < containerRect.left || rect.bottom < containerRect.top ||
             rect.left > containerRect.right || rect.top > containerRect.bottom) &&
             style.overflow == 'hidden') {
        return true;
    }

    if (rect.right < containerScrollArea.left || rect.bottom < containerScrollArea.top)
        return (style.overflow != 'visible');

    return false;
};

/**
 * @param {Node} ancestor A potential ancestor of |node|.
 * @param {Node} node
 * @return {boolean} true if |ancestor| is an ancestor of |node| (including
 *     |ancestor| === |node|).
 */
axs.utils.isAncestor = function(ancestor, node) {
    if (node == null)
        return false;
    if (node === ancestor)
        return true;

    return axs.utils.isAncestor(ancestor, node.parentNode);
};

/**
 * @param {Element} element
 * @return {Array.<Element>} An array of any non-transparent elements which
 *     overlap the given element.
 */
axs.utils.overlappingElements = function(element) {
    if (axs.utils.elementHasZeroArea(element))
        return null;

    var overlappingElements = [];
    var clientRects = element.getClientRects();
    for (var i = 0; i < clientRects.length; i++) {
        var rect = clientRects[i];
        var center_x = (rect.left + rect.right) / 2;
        var center_y = (rect.top + rect.bottom) / 2;
        var elementAtPoint = document.elementFromPoint(center_x, center_y);

        if (elementAtPoint == null || elementAtPoint == element ||
            axs.utils.isAncestor(elementAtPoint, element) ||
            axs.utils.isAncestor(element, elementAtPoint)) {
            continue;
        }

        var overlappingElementStyle = window.getComputedStyle(elementAtPoint, null);
        if (!overlappingElementStyle)
            continue;

        var overlappingElementBg = axs.utils.getBgColor(overlappingElementStyle,
                                                        elementAtPoint);
        if (overlappingElementBg && overlappingElementBg.alpha > 0 &&
            overlappingElements.indexOf(elementAtPoint) < 0) {
            overlappingElements.push(elementAtPoint);
        }
    }

    return overlappingElements;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementIsHtmlControl = function(element) {
    var defaultView = element.ownerDocument.defaultView;

    // HTML control
    if (element instanceof defaultView.HTMLButtonElement)
        return true;
    if (element instanceof defaultView.HTMLInputElement)
        return true;
    if (element instanceof defaultView.HTMLSelectElement)
        return true;
    if (element instanceof defaultView.HTMLTextAreaElement)
        return true;

    return false;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementIsAriaWidget = function(element) {
    if (element.hasAttribute('role')) {
        var roleValue = element.getAttribute('role');
        // TODO is this correct?
        if (roleValue) {
            var role = axs.constants.ARIA_ROLES[roleValue];
            if (role && 'widget' in role['allParentRolesSet'])
                return true;
        }
    }
    return false;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
axs.utils.elementIsVisible = function(element) {
    if (axs.utils.elementIsTransparent(element))
        return false;
    if (axs.utils.elementHasZeroArea(element))
        return false;
    if (axs.utils.elementIsOutsideScrollArea(element))
        return false;

    var overlappingElements = axs.utils.overlappingElements(element);
    if (overlappingElements.length)
        return false;

    return true;
};

/**
 * @param {CSSStyleDeclaration} style
 * @return {boolean}
 */
axs.utils.isLargeFont = function(style) {
    var fontSize = style.fontSize;
    var bold = style.fontWeight == 'bold';
    var matches = fontSize.match(/(\d+)px/);
    if (matches) {
        var fontSizePx = parseInt(matches[1], 10);
        var bodyStyle = window.getComputedStyle(document.body, null);
        var bodyFontSize = bodyStyle.fontSize;
        matches = bodyFontSize.match(/(\d+)px/);
        if (matches) {
            var bodyFontSizePx = parseInt(matches[1], 10);
            var boldLarge = bodyFontSizePx * 1.2;
            var large = bodyFontSizePx * 1.5;
        } else {
            var boldLarge = 19.2;
            var large = 24;
        }
        return (bold && fontSizePx >= boldLarge || fontSizePx >= large);
    }
    matches = fontSize.match(/(\d+)em/);
    if (matches) {
        var fontSizeEm = parseInt(matches[1], 10);
        if (bold && fontSizeEm >= 1.2 || fontSizeEm >= 1.5)
            return true;
        return false;
    }
    matches = fontSize.match(/(\d+)%/);
    if (matches) {
        var fontSizePercent = parseInt(matches[1], 10);
        if (bold && fontSizePercent >= 120 || fontSizePercent >= 150)
            return true;
        return false;
    }
    matches = fontSize.match(/(\d+)pt/);
    if (matches) {
        var fontSizePt = parseInt(matches[1], 10);
        if (bold && fontSizePt >= 14 || fontSizePt >= 18)
            return true;
        return false;
    }
    return false;
};

/**
 * @param {CSSStyleDeclaration} style
 * @param {Element} element
 * @return {?axs.utils.Color}
 */
axs.utils.getBgColor = function(style, element) {
    var bgColorString = style.backgroundColor;
    var bgColor = axs.utils.parseColor(bgColorString);
    if (!bgColor)
        return null;

    if (style.opacity < 1)
        bgColor.alpha = bgColor.alpha * style.opacity;

    if (bgColor.alpha < 1) {
        var parentBg = axs.utils.getParentBgColor(element);
        if (parentBg == null)
            return null;

        bgColor = axs.utils.flattenColors(bgColor, parentBg);
    }
    return bgColor;
};

/**
 * Gets the effective background color of the parent of |element|.
 * @param {Element} element
 * @return {?axs.utils.Color}
 */
axs.utils.getParentBgColor = function(element) {
    /** @type {Element} */ var parent = element;
    var bgStack = [];
    var foundSolidColor = null;
    while (parent = axs.utils.parentElement(parent)) {
        var computedStyle = window.getComputedStyle(parent, null);
        if (!computedStyle)
            continue;

        var parentBg = axs.utils.parseColor(computedStyle.backgroundColor);
        if (!parentBg)
            continue;

        if (computedStyle.opacity < 1)
            parentBg.alpha = parentBg.alpha * computedStyle.opacity;

        if (parentBg.alpha == 0)
            continue;

        bgStack.push(parentBg);

        if (parentBg.alpha == 1) {
            foundSolidColor = true;
            break;
        }
    }

    if (!foundSolidColor)
        bgStack.push(new axs.utils.Color(255, 255, 255, 1));

    var bg = bgStack.pop();
    while (bgStack.length) {
        var fg = bgStack.pop();
        bg = axs.utils.flattenColors(fg, bg);
    }
    return bg;
};

/**
 * @param {CSSStyleDeclaration} style
 * @param {Element} element
 * @param {axs.utils.Color} bgColor The background color, which may come from
 *    another element (such as a parent element), for flattening into the
 *    foreground color.
 * @return {?axs.utils.Color}
 */
axs.utils.getFgColor = function(style, element, bgColor) {
    var fgColorString = style.color;
    var fgColor = axs.utils.parseColor(fgColorString);
    if (!fgColor)
        return null;

    if (fgColor.alpha < 1)
        fgColor = axs.utils.flattenColors(fgColor, bgColor);

    if (style.opacity < 1) {
        var parentBg = axs.utils.getParentBgColor(element);
        fgColor.alpha = fgColor.alpha * style.opacity;
        fgColor = axs.utils.flattenColors(fgColor, parentBg);
    